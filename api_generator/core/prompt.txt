engineers
engineers
Watching for file changes with StatReloader
2025-05-09 15:52:22,373 - INFO - Watching for file changes with StatReloader
Performing system checks...

System check identified some issues:

WARNINGS:
?: (urls.W005) URL namespace 'admin' isn't unique. You may not be able to reverse all URLs in this namespace

System check identified 1 issue (0 silenced).
May 09, 2025 - 15:52:22
Django version 5.1.1, using settings 'api_generator.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CTRL-BREAK.

2025-05-09 15:55:18,128 - ERROR - Template compilation failed for feed.html, mode=after: Invalid block tag on line 8: 'static'. Did you forget to register or load this tag?
Traceback (most recent call last):
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\base.py", line 510, in parse
    compile_func = self.tags[command]
                   ~~~~~~~~~^^^^^^^^^
KeyError: 'static'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\api_generator\create_api\views.py", line 2458, in get   
    template = django_engine.from_string(content)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\backends\django.py", line 75, in from_string
    return Template(self.engine.from_string(template_code), self)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\engine.py", line 170, in from_string
    return Template(template_code, engine=self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\base.py", line 154, in __init__
    self.nodelist = self.compile_nodelist()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\base.py", line 196, in compile_nodelist
    nodelist = parser.parse()
               ^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\base.py", line 512, in parse
    self.invalid_block_tag(token, command, parse_until)
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\base.py", line 573, in invalid_block_tag
    raise self.error(
django.template.exceptions.TemplateSyntaxError: Invalid block tag on line 8: 'static'. Did you forget to register or load this tag?
Internal Server Error: /api/projects/1/preview/one/84/
2025-05-09 15:55:18,132 - ERROR - Template rendering failed for feed.html, mode=before: context must be a dict rather than RequestContext.
Traceback (most recent call last):
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\api_generator\create_api\views.py", line 2477, in get   
    rendered = template.render(ctx)
               ^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\backends\django.py", line 103, in render
    context = make_context(
              ^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\context.py", line 288, in make_context
    raise TypeError(
TypeError: context must be a dict rather than RequestContext.
Internal Server Error: /api/projects/1/preview/one/84/
2025-05-09 15:55:18,158 - ERROR - Internal Server Error: /api/projects/1/preview/one/84/
2025-05-09 15:55:18,160 - ERROR - Internal Server Error: /api/projects/1/preview/one/84/
[09/May/2025 15:55:18] "GET /api/projects/1/preview/one/84/?mode=before&file=templates/feed.html HTTP/1.1" 500 88
[09/May/2025 15:55:18] "GET /api/projects/1/preview/one/84/?mode=after&file=templates/feed.html HTTP/1.1" 500 123
2025-05-09 15:55:18,173 - ERROR - Template compilation failed for feed.html, mode=after: Invalid block tag on line 8: 'static'. Did you forget to register or load this tag?
Traceback (most recent call last):
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\base.py", line 510, in parse
    compile_func = self.tags[command]
                   ~~~~~~~~~^^^^^^^^^
KeyError: 'static'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\api_generator\create_api\views.py", line 2458, in get   
    template = django_engine.from_string(content)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\backends\django.py", line 75, in from_string
    return Template(self.engine.from_string(template_code), self)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\engine.py", line 170, in from_string
    return Template(template_code, engine=self)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\base.py", line 154, in __init__
    self.nodelist = self.compile_nodelist()
                    ^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\base.py", line 196, in compile_nodelist
    nodelist = parser.parse()
               ^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\base.py", line 512, in parse
    self.invalid_block_tag(token, command, parse_until)
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\base.py", line 573, in invalid_block_tag
    raise self.error(
django.template.exceptions.TemplateSyntaxError: Invalid block tag on line 8: 'static'. Did you forget to register or load this tag?
Internal Server Error: /api/projects/1/preview/one/84/
2025-05-09 15:55:18,176 - ERROR - Internal Server Error: /api/projects/1/preview/one/84/
[09/May/2025 15:55:18] "GET /api/projects/1/preview/one/84/?mode=after&file=templates/feed.html HTTP/1.1" 500 123
2025-05-09 15:55:18,178 - ERROR - Template rendering failed for feed.html, mode=before: context must be a dict rather than RequestContext.
Traceback (most recent call last):
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\api_generator\create_api\views.py", line 2477, in get   
    rendered = template.render(ctx)
               ^^^^^^^^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\backends\django.py", line 103, in render
    context = make_context(
              ^^^^^^^^^^^^^
  File "C:\Users\yasse\OneDrive\Desktop\Pre-Coded\venv\Lib\site-packages\django\template\context.py", line 288, in make_context
    raise TypeError(
TypeError: context must be a dict rather than RequestContext.
Internal Server Error: /api/projects/1/preview/one/84/
2025-05-09 15:55:18,180 - ERROR - Internal Server Error: /api/projects/1/preview/one/84/
[09/May/2025 15:55:18] "GET /api/projects/1/preview/one/84/?mode=before&file=templates/feed.html HTTP/1.1" 500 88



this is my setup:
"""
Django settings for api_generator project.

Generated by 'django-admin startproject' using Django 5.1.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from datetime import timedelta
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
# put all dynamic previews in a sibling folder, not under BASE_DIR
PREVIEW_ROOT = BASE_DIR.parent / "dynamic_previews"
# ensure it exists at startup
PREVIEW_ROOT.mkdir(exist_ok=True, parents=True)

# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-8nnd!w13nd3p9vo^7oa=&i6=4dz55chk2&78_c6*0p1je39mt!'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*']


# Application definition

INSTALLED_APPS = [
     "channels",
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    # 'django.contrib.staticfiles',
    'rest_framework',
        'rest_framework_simplejwt',
    'core.apps.CoreConfig',
    'projects.apps.ProjectsConfig',
# 'django.contrib.staticfiles',

    'corsheaders',  
    'create_api.apps.CreateApiConfig',
]
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
]
CORS_ALLOW_CREDENTIALS = True
import sys
from pathlib import Path
DYNAMIC_APPS_PATH = Path(__file__).resolve().parent.parent / "dynamic_apps"
sys.path.insert(0, str(DYNAMIC_APPS_PATH))




REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
     'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',  # Require authentication for all views
    ],
}
AUTHENTICATION_BACKENDS = [
    "core.backends.ProjectDBBackend",  
    "django.contrib.auth.backends.ModelBackend",
]

MIDDLEWARE = [
    # 1) detect project-alias first

    'core.middleware.PreviewDiffMiddleware',
"core.middleware.ProjectDBMiddleware",
    # 2) patch register/login to write into the project DB and record alias
    'core.middleware.PatchRegisterAndLoginMiddleware',

    # 3) Django’s built-in session & auth middlewares
    'django.contrib.sessions.middleware.SessionMiddleware',
    
    'django.contrib.auth.middleware.AuthenticationMiddleware',
        'corsheaders.middleware.CorsMiddleware',

    # 4) now re-hydrate request.user from project DB
    
    'core.middleware.ProjectSessionAuthMiddleware',

    # your other middleware…
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    # 'django.contrib.messages.middleware.ThemeInjectorMiddleware',
    # … etc.
]

ROOT_URLCONF = 'api_generator.urls'

CSP_SCRIPT_SRC = (
    "'self'",
    "'unsafe-inline'",    # you may already have this
    "'unsafe-eval'",      # ← allow eval() inside those bundles
    "https://code.jquery.com",
    "https://cdn.jsdelivr.net",
)
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': False,
        'OPTIONS': {
             'loaders': [
                'core.loaders.DatabaseLoader',
                'django.template.loaders.filesystem.Loader',
                'django.template.loaders.app_directories.Loader',
            ],
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
            
        },
    },
]

WSGI_APPLICATION = 'api_generator.wsgi.application'
# Tell Django to use Channels’ ASGI app
ASGI_APPLICATION = "api_generator.asgi.application"

from channels.layers import InMemoryChannelLayer
CHANNEL_LAYERS = {
    "default": {
        # In-memory channel layer for dev & single‐process use
        "BACKEND": "channels.layers.InMemoryChannelLayer",
    },
}

# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# route project_<id>_app_label to project_<id> database
DATABASE_ROUTERS = ['core.db_router.ProjectRouter']

# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
}


CORS_ALLOW_ALL_ORIGINS = True

# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True
STATICFILES_FINDERS = [
    'core.db_static.DatabaseStaticFinder',
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
]

STATICFILES_STORAGE = 'core.db_static.DatabaseStaticStorage'


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'
STATIC_URL = '/static/'


# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
DEFAULT_FILE_STORAGE = 'core.db_media.HybridMediaStorage'

# api_generator/asgi_ws.py

import os
import sys
import logging
import threading
import django
import asyncio
from django.core.asgi import get_asgi_application
from django.conf import settings
from django.apps import apps as global_apps
from asgiref.sync import sync_to_async
from django.core.management import call_command
from pathlib import Path

logger = logging.getLogger(__name__)
# === NEW: ignore reloads on our preview folder ===
from django.utils.autoreload import file_changed
def _ignore_preview_changes(sender, file_path, **kwargs):
    p = Path(file_path)
    if "dynamic_apps_preview" in p.parts and any(part.startswith(("before_","after_")) for part in p.parts):
        return True
    return False
file_changed.connect(_ignore_preview_changes)
# === end ignore hook ===
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "api_generator.settings")
sys.path.insert(0, os.path.dirname(__file__))

from core.early import dynamic_register_databases_early, dynamic_register_apps_early
dynamic_register_databases_early()
dynamic_register_apps_early()

import core.apps as _core_apps
def _core_ready_minimal(self):
    from core.db_importer import install as _install_db_finder
    _install_db_finder()
_core_apps.CoreConfig.ready = _core_ready_minimal

django.setup()

file_write_lock = threading.Lock()

@sync_to_async
def dynamic_register_databases():
    from core.startup import dynamic_register_databases
    dynamic_register_databases()

@sync_to_async
def dynamic_register_and_dump():
    from core.startup import dynamic_register_and_dump
    with file_write_lock:
        dynamic_register_and_dump()
        logger.debug("App registry after dump: %s", list(global_apps.app_configs.keys()))

@sync_to_async
def generate_and_apply_migrations():
    from django.db import connections
    with file_write_lock:
        try:
            dynamic_apps = [label for label in global_apps.app_configs if label.startswith("project_")]
            for app_label in dynamic_apps:
                logger.debug(f"Generating migrations for {app_label}")
                call_command("makemigrations", app_label, interactive=False, no_input=True, verbosity=1)
            for db in settings.DATABASES:
                if db.startswith("project_"):
                    logger.debug(f"Applying migrations for database {db}")
                    call_command("migrate", database=db, fake_initial=True, no_input=True)
        except Exception:
            logger.exception("Migration error")

async def initialize_dynamic_apps():
    try:
        from core.db_importer import install as install_db_importer
        install_db_importer()

        await dynamic_register_databases()
        await dynamic_register_and_dump()

        settings.MIGRATION_MODULES = getattr(settings, "MIGRATION_MODULES", {})
        for cfg in global_apps.get_app_configs():
            if cfg.label.startswith("project_"):
                settings.MIGRATION_MODULES[cfg.label] = f"dynamic_apps.{cfg.label}.migrations"

        await generate_and_apply_migrations()
        logger.info("Dynamic apps initialized successfully.")
    except Exception:
        logger.exception("Dynamic initialization failed")
        raise

async def lifespan_handler(scope, receive, send):
    if scope["type"] != "lifespan":
        raise RuntimeError("Expected lifespan scope")

    try:
        while True:
            message = await receive()
            if message["type"] == "lifespan.startup":
                logger.info("Received lifespan.startup")
                try:
                    await initialize_dynamic_apps()
                    await send({"type": "lifespan.startup.complete"})
                    logger.info("Lifespan startup complete")
                except Exception:
                    await send({"type": "lifespan.startup.failed"})
            elif message["type"] == "lifespan.shutdown":
                logger.info("Received lifespan.shutdown")
                await send({"type": "lifespan.shutdown.complete"})
                break
    except asyncio.CancelledError:
        logger.debug("Lifespan cancelled by reload; exiting lifespan_handler.")

from channels.routing import ProtocolTypeRouter, URLRouter
from django.urls import re_path
from core.middleware import QueryAuthMiddleware
from create_api.consumers import AIChatConsumer

application = ProtocolTypeRouter({
    "http": get_asgi_application(),
    "websocket": QueryAuthMiddleware(
        URLRouter([
            re_path(r"^ws/projects/(?P<project_id>\d+)/ai/$", AIChatConsumer.as_asgi()),
        ])
    ),
    "lifespan": lifespan_handler,
})
"""
WSGI config for api_generator project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""


from django.core.wsgi import get_wsgi_application

import os
import sys

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "api_generator.settings")
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

import django
django.setup()

from core.db_importer import install as install_db_finder
install_db_finder()

application = get_wsgi_application()



# core/apps.py
from django.apps import AppConfig

class CoreConfig(AppConfig):
    name = 'core'

def ready(self):
        from core.db_importer import install as _install_db_finder
        _install_db_finder()
        from django.conf import settings
        try:
            from create_api.models import Project
            for proj in Project.objects.all():
                alias = f"project_{proj.pk}"
                if alias in settings.DATABASES:
                    continue
                settings.DATABASES[alias] = {
                    'ENGINE': 'django.db.backends.sqlite3',
                    'NAME': settings.BASE_DIR / f"{alias}.sqlite3",
                }
        except Exception:
            # Skip ORM operations if database is not ready (e.g., during ASGI startup)
            pass




import sys
import importlib.abc
import importlib.util
import importlib.machinery
from django.apps import apps
import logging
import os
from core.importer_local import importer_local

logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler()]
)

def sanitize_content(content):
    return content.replace('\xa0', ' ')

class DBModuleLoader(importlib.abc.Loader):
    def __init__(self, record):
        self.record = record

    def create_module(self, spec):
        return None

    def exec_module(self, module):
        from django.db import models as dj_models
        from django.conf import settings

        raw = self.record.content.replace('\xa0', ' ')
        import re
        def strip_reverse_accessors(code):
            pattern = re.compile(r"""
                (?P<prefix>\w+\s*=\s*models\.
                    (ForeignKey|OneToOneField)\(
                )
                (?P<args>.*?)
                \)
            """, re.VERBOSE)
            def replacer(m):
                args = re.sub(r"related_name\s*=\s*['\"].*?['\"]\s*,?", "", m.group("args"))
                return f"{m.group('prefix')}{args.rstrip(', ')}, related_name='+' )"
            return pattern.sub(replacer, code)

        sanitized = strip_reverse_accessors(raw)
        exec(sanitized, module.__dict__)
        label = f"project_{self.record.project_id}_{self.record.app.name}"

        for attr in dir(module):
            cls = getattr(module, attr)
            if (
                isinstance(cls, type)
                and issubclass(cls, dj_models.Model)
                and cls is not dj_models.Model
                and cls.__module__ == module.__name__
            ):
                for field in cls._meta.local_fields:
                    if isinstance(field, (dj_models.ForeignKey, dj_models.OneToOneField)):
                        field.remote_field.related_name = '+'
                        field.remote_field.related_query_name = None

        auth_model = apps.get_model(settings.AUTH_USER_MODEL)
        for attr in dir(module):
            cls = getattr(module, attr)
            if (
                isinstance(cls, type)
                and issubclass(cls, dj_models.Model)
                and cls is not dj_models.Model
                and cls.__module__ == module.__name__
            ):
                cls._meta.app_label = label
                cls._meta.db_table = f"{label}_{cls._meta.model_name}"
                origin = getattr(module.__spec__, 'origin', '') or ''
                if origin.startswith('db://'):
                    real = os.path.join(settings.BASE_DIR, "dynamic_apps")
                    if real not in sys.path:
                        sys.path.insert(0, real)
                    app_config = apps.get_app_config(label)
                    if cls._meta.model_name not in app_config.models:
                        try:
                            apps.register_model(label, cls)
                        except RuntimeError:
                            pass
                for field in cls._meta.get_fields():
                    rf = getattr(field, "remote_field", None)
                    if rf and isinstance(rf.model, str):
                        try:
                            apps.get_model(rf.model)
                        except LookupError:
                            if rf.model.rsplit(".", 1)[-1] == "User":
                                rf.model = auth_model
                for field in cls._meta.local_fields:
                    rf = getattr(field, "remote_field", None)
                    if rf and rf.model is auth_model:
                        field.db_constraint = False

class DBModuleFinder(importlib.abc.MetaPathFinder):
    PREFIX = "projects"

    def _get_db_app_names(self, project_id):
        from create_api.models import App
        return set(App.objects.filter(project_id=project_id).values_list("name", flat=True))
    
    def find_spec(self, fullname, path, target=None):
        # Prevent model loading during app registry population
        if getattr(importer_local, 'populating', False):
            logging.debug(f"Skipping find_spec for {fullname} during app registry population")
            return None

        db_alias = getattr(importer_local, 'db_alias', 'default')
        if "migrations" in fullname.split(".") or "templatetags" in fullname.split("."):
            return None
        if fullname in sys.modules:
            return None
        parts = fullname.split(".")
        if not fullname.startswith(self.PREFIX):
            return None
        if len(parts) < 2:
            return None

        tag = parts[1]
        if tag.isdigit():
            project_id = int(tag)
        elif tag.startswith("project_") and tag.split("_", 1)[1].isdigit():
            project_id = int(tag.split("_", 1)[1])
        else:
            return None

        if len(parts) >= 4 and parts[2] == "apps":
            app_name = parts[3]
            if len(parts) == 4 or (len(parts) > 4 and parts[4] == "__init__"):
                Model = apps.get_model("create_api", "AppFile")
                for init_path in [
                    f"{app_name}/__init__.py",
                    f"apps/{app_name}/__init__.py",
                    f"{app_name}/{app_name}/__init__.py",
                    f"__init__.py"
                ]:
                    try:
                        record = Model.objects.using(db_alias).get(
                            project_id=project_id,
                            app__name=app_name,
                            path=init_path,
                        )
                        loader = DBModuleLoader(record)
                        spec = importlib.util.spec_from_loader(
                            fullname,
                            loader,
                            origin=f"db://{fullname}",
                            is_package=True
                        )
                        spec.submodule_search_locations = [os.path.dirname(record.path)]
                        return spec
                    except Model.DoesNotExist:
                        continue
                logging.debug(f"No __init__.py found for app {app_name}")
                return None

        if len(parts) == 2:
            spec = importlib.machinery.ModuleSpec(fullname, loader=None, is_package=True)
            spec.submodule_search_locations = []
            return spec

        if len(parts) == 3 and parts[2] == "apps":
            spec = importlib.machinery.ModuleSpec(fullname, loader=None, is_package=True)
            spec.submodule_search_locations = []
            return spec

        elif len(parts) == 4 and parts[2] == "apps":
            from create_api.models import App
            app_name = parts[3]
            if App.objects.filter(project_id=project_id, name=app_name).exists():
                Model = apps.get_model("create_api", "AppFile")
                possible_paths = [
                    f"apps/{app_name}/__init__.py",
                    f"{app_name}/__init__.py",
                ]
                for init_path in possible_paths:
                    try:
                        record = Model.objects.using(db_alias).get(
                            project_id=project_id,
                            app__name=app_name,
                            path=init_path,
                        )
                        loader = DBModuleLoader(record)
                        package_dir = os.path.dirname(record.path)
                        spec = importlib.util.spec_from_loader(
                            fullname,
                            loader,
                            origin=f"db://{fullname}",
                            is_package=True,
                        )
                        spec.submodule_search_locations = [package_dir]
                        return spec
                    except Model.DoesNotExist:
                        continue
                spec = importlib.machinery.ModuleSpec(
                    fullname,
                    loader=None,
                    is_package=True,
                )
                spec.submodule_search_locations = []
                return spec
            return None

        if parts[2] == "urls" and len(parts) == 3:
            Model = apps.get_model("create_api", "URLFile")
            rel_path = "urls.py"
            filters = {"project_id": project_id, "app__isnull": True, "path": rel_path}
            try:
                record = Model.objects.using(db_alias).get(**filters)
                loader = DBModuleLoader(record)
                return importlib.util.spec_from_loader(
                    fullname,
                    loader,
                    origin=f"db://{fullname}"
                )
            except Model.DoesNotExist:
                logging.error(f"Module not found with filters: {filters}")
                return None

        elif len(parts) == 3:
            Model = apps.get_model("create_api", "ProjectFile")
            rel_path = f"{parts[2]}.py"
            filters = {"project_id": project_id, "path": rel_path}
            try:
                record = Model.objects.using(db_alias).get(**filters)
                loader = DBModuleLoader(record)
                return importlib.util.spec_from_loader(
                    fullname,
                    loader,
                    origin=f"db://{fullname}"
                )
            except Model.DoesNotExist:
                logging.error(f"Module not found with filters: {filters}")
                return None

        elif (
            (parts[2] == "apps" and len(parts) >= 4)
            or (len(parts) >= 4 and parts[2] in self._get_db_app_names(project_id))
        ):
            if parts[2] == "apps":
                app_name, module_parts = parts[3], parts[4:]
            else:
                app_name, module_parts = parts[2], parts[3:]
            possible_paths = [
                f"{'/'.join(module_parts)}.py",
                f"{app_name}/{'/'.join(module_parts)}.py",
                f"apps/{app_name}/{'/'.join(module_parts)}.py",
            ]
            for model_name in ("ModelFile", "ViewFile", "FormFile", "URLFile", "AppFile"):
                Model = apps.get_model("create_api", model_name)
                for path in possible_paths:
                    try:
                        record = Model.objects.using(db_alias).get(
                            project_id=project_id,
                            app__name=app_name,
                            path=path,
                        )
                        loader = DBModuleLoader(record)
                        return importlib.util.spec_from_loader(
                            fullname,
                            loader,
                            origin=f"db://{fullname}",
                            is_package=False,
                        )
                    except Model.DoesNotExist:
                        continue
            logging.error(f"Module not found for {fullname} with paths: {possible_paths}")
            return None
        return None

def install():
    sys.meta_path.insert(0, DBModuleFinder())


# core/db_media.py

from django.core.files.storage import FileSystemStorage
from django.conf import settings
from create_api.models import MediaFile, Project

class HybridMediaStorage(FileSystemStorage):
    """
    • Writes files under MEDIA_ROOT as usual.
    • Then upserts a matching MediaFile record with the correct project FK.
    """

    def _save(self, name, content):
        # 1) Save to disk
        saved_name = super()._save(name, content)

        # 2) Derive project from the path: expect "projects/<project_id>/…"
        project = None
        parts = name.split("/")  # ALWAYS forward-slash here
        if len(parts) >= 2 and parts[0] == "projects" and parts[1].isdigit():
            try:
                project = Project.objects.get(id=int(parts[1]))
            except Project.DoesNotExist:
                project = None

        # 3) Upsert the MediaFile record
        MediaFile.objects.update_or_create(
            path=name,
            defaults={
                "file": saved_name,
                "project": project,
            }
        )

        return saved_name

    def delete(self, name):
        # delete from disk
        super().delete(name)
        # delete from DB
        MediaFile.objects.filter(path=name).delete()
class ProjectRouter:
    """
    Routes models in apps labeled "project_<id>_<appname>" to the "project_<id>" database,
    and allows them to FK back to auth.User in the default DB.
    """

    def db_for_read(self, model, **hints):
        label = model._meta.app_label
        if label.startswith('project_'):
            parts = label.split('_', 2)
            return f"project_{parts[1]}"
        return None

    def db_for_write(self, model, **hints):
        return self.db_for_read(model, **hints)

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        if app_label.startswith('project_'):
            parts = app_label.split('_', 2)
            return db == f"project_{parts[1]}"
        return db == 'default'

    def allow_relation(self, obj1, obj2, **hints):
        lab1 = obj1._meta.app_label
        lab2 = obj2._meta.app_label

        # if either model is in a project_<id> app, allow the relation
        if lab1.startswith('project_') or lab2.startswith('project_'):
            return True

        # otherwise, fall back to Django’s default (None)
        return None
# core/db_static.py

from django.contrib.staticfiles.finders import BaseFinder
from django.contrib.staticfiles.storage import StaticFilesStorage
from django.core.files.base import ContentFile
from create_api.models import StaticFile

class DatabaseStaticStorage(StaticFilesStorage):
    """
    Storage backend that reads StaticFile.file out of the DB.
    """
    def _open(self, name, mode='rb'):
        try:
            record = StaticFile.objects.get(path=name)
        except StaticFile.DoesNotExist:
            raise FileNotFoundError(f"No static file in DB for {name!r}")
        return record.file

    def exists(self, name):
        return StaticFile.objects.filter(path=name).exists()

class DatabaseStaticFinder(BaseFinder):
    """
    Finder that looks up every requested static path in the DB.
    """
    storage = DatabaseStaticStorage()

    def find(self, path, all=False):
        """
        Return the “path” if we have it in the DB, otherwise let other finders run.
        """
        if self.storage.exists(path):
            return [path] if all else path
        return [] if all else None

    def list(self, ignore_patterns):
        """
        Yield (path, path) for every DB record so runserver or collectstatic can see them.
        """
        for record in StaticFile.objects.all():
            yield record.path, record.path


from django.template.loaders.base import Loader
from django.template import Origin, TemplateDoesNotExist
from create_api.models import TemplateFile
import logging

logger = logging.getLogger(__name__)

class DatabaseLoader(Loader):
    is_usable = True

    def get_template_sources(self, template_name):
        try:
            tf = TemplateFile.objects.get(path=template_name)
        except TemplateFile.DoesNotExist:
            return
        yield Origin(
            name=f"db://{template_name}",
            template_name=template_name,
            loader=self
        )

    def get_contents(self, origin):
        # 1) Load the content from the DB
        try:
            tf = TemplateFile.objects.get(path=origin.template_name)
            content = tf.content
        except TemplateFile.DoesNotExist:
            raise TemplateDoesNotExist(origin)

        # 2) If middleware has injected a preview_diff, apply it
        request = getattr(self.engine, "request", None)
        diffs = getattr(request, "preview_diff", None)
        if isinstance(diffs, dict):
            # keys in preview_diff should match template_name
            patched = diffs.get(origin.template_name)
            if patched is not None:
                logger.debug(f"DatabaseLoader: using preview diff for {origin.template_name}")
                return patched

        # 3) Otherwise return the unmodified DB content
        return content
# core/migration.py

import importlib
from pathlib import Path

from django.apps import apps as global_apps
from django.conf import settings
from django.core.management import call_command
from django.db import connections, utils as db_utils

def auto_apply_migrations():
    # 1) Group dynamic apps by project ID
    projects = {}
    for cfg in global_apps.get_app_configs():
        if not cfg.label.startswith("project_"):
            continue
        pid = cfg.label.split("_", 2)[1]
        projects.setdefault(pid, []).append(cfg)

    # 2) For each project, run makemigrations + migrate + fallback
    for project_id, cfgs in projects.items():
        db_alias = f"project_{project_id}"

        # 2a) Ensure at least one migration file exists per app
        for cfg in cfgs:
            migrations_dir = Path(settings.BASE_DIR) / "dynamic_apps" / cfg.label / "migrations"
            if not any(migrations_dir.glob("00*.py")):
                call_command("makemigrations", cfg.label, interactive=False, verbosity=0)
        # 2b) Migrate all apps on this DB, faking any “initial” migrations
        #    whose tables already exist
        print(f"→ [project_{project_id}] migrating all apps on {db_alias} (fake_initial=True)")
        call_command(
            "migrate",
            database=db_alias,
            interactive=False,
            verbosity=1,
            fake_initial=True,
        )

        # 2c) Fallback: create any managed-model tables not yet created
        conn     = connections[db_alias]
        existing = set(conn.introspection.table_names())

        for cfg in cfgs:
            try:
                models_mod = importlib.import_module(f"{cfg.name}.models")
            except ModuleNotFoundError:
                continue

            for attr in dir(models_mod):
                cls = getattr(models_mod, attr)
                if (
                    isinstance(cls, type)
                    and hasattr(cls, "_meta")
                    and cls._meta.managed
                    and not cls._meta.auto_created
                ):
                    table = cls._meta.db_table
                    if table not in existing:
                        try:
                            with conn.schema_editor() as editor:
                                editor.create_model(cls)
                            existing.add(table)
                            print(f"↳ [project_{project_id}] fallback-created `{table}`")
                        except db_utils.OperationalError as e:
                            # If the table already exists, ignore and continue
                            if "already exists" in str(e):
                                print(f"⚠️ [project_{project_id}] skipped existing table `{table}`")
                                existing.add(table)
                            else:
                                # Re-raise unexpected OperationalErrors
                                raiseimport inspect
import re
from django import forms
from django.contrib import messages
from django.contrib.auth import get_user_model, login, logout, SESSION_KEY, BACKEND_SESSION_KEY
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth.models import AnonymousUser
from django.contrib.auth.views import LoginView
from django.views.generic import FormView
from django.contrib.auth import logout, SESSION_KEY, BACKEND_SESSION_KEY
from urllib.parse import parse_qs
from rest_framework_simplejwt.authentication import JWTAuthentication
from rest_framework_simplejwt.exceptions import InvalidToken, TokenError

import json
from django.utils.deprecation import MiddlewareMixin
from create_api.models import AIChangeRequest


class ProjectDBMiddleware:
    """
    Reads /projects/<id>/ from the URL and sets request.project_db_alias.
    """
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        parts = request.path_info.strip("/").split("/")
        if len(parts) >= 2 and parts[0] == "projects" and parts[1].isdigit():
            request.project_db_alias = f"project_{parts[1]}"
        else:
            request.project_db_alias = "default"
        return self.get_response(request)


class PatchRegisterAndLoginMiddleware:
    """
    Patches registration and login views to scope auth to the proper DB.
    """
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        return self.get_response(request)

    def process_view(self, request, view_func, view_args, view_kwargs):
        alias = getattr(request, 'project_db_alias', 'default')
        view_cls = getattr(view_func, 'view_class', None)

        # Avoid double-patching
        if not hasattr(view_cls, '_project_patched') and view_cls:
            # Patch RegisterView
            # Patch RegisterView: wrap both its form_class *and* form_valid so that
            # (1) username-uniqueness checks against project_<id> DB
            # (2) .save() writes into that DB
            # (3) session backend is set to ProjectDBBackend
            if view_cls.__name__ == 'RegisterView':
                # Wrap the view’s form to look at self.request.project_db_alias each time
                orig_form = getattr(view_cls, 'form_class', None)
                class ScopedRegisterForm(orig_form):
                    def __init__(self, *args, **kwargs):
                        super().__init__(*args, **kwargs)
                        # attach the request so we can read alias dynamically
                        self.request = kwargs.get('request') or request
    
                    def clean_username(self):
                        alias = (
                            self.request.project_db_alias
                            or self.request.session.get('project_db_alias', 'default')
                        )
                        uname = self.cleaned_data.get('username')
                        from django.contrib.auth import get_user_model
                        User = get_user_model()
                        if User._default_manager.db_manager(alias).filter(username=uname).exists():
                            raise forms.ValidationError(
                                self.error_messages.get('duplicate_username',
                                                         'A user with that username already exists.'),
                                code='duplicate_username'
                            )
                        return uname
    
                    def save(self, commit=True):
                        alias = (
                            self.request.project_db_alias
                            or self.request.session.get('project_db_alias', 'default')
                        )
                        user = super().save(commit=False)
                        if commit:
                            user.save(using=alias)
                        return user
    
                    def validate_unique(self):
                        # don't run default-DB unique checks
                        pass
    
                view_cls.form_class = ScopedRegisterForm
    
                # And patch form_valid to log in from the same dynamic alias
                orig_valid = view_cls.form_valid
                def form_valid(self, form):
                    alias = (
                        self.request.project_db_alias
                        or self.request.session.get('project_db_alias', 'default')
                    )
                    user = form.save(commit=True)  # uses our save(using=alias)
    
                    # pick correct backend
                    backend = (
                        'core.backends.ProjectDBBackend'
                        if alias != 'default'
                        else 'django.contrib.auth.backends.ModelBackend'
                    )
                    user.backend = backend
    
                    login(self.request, user)
                    request.session[SESSION_KEY]         = user.pk
                    request.session[BACKEND_SESSION_KEY] = backend
                    if alias != 'default':
                        request.session['project_db_alias'] = alias
    
                    return orig_valid(self, form)
    
                view_cls.form_valid = form_valid
                view_cls._project_patched = True
                return None

            # Patch dynamic UserCreationForm on any FormView
            if issubclass(view_cls, FormView):
                form_cls = getattr(view_cls, 'form_class', None)
                if form_cls and issubclass(form_cls, UserCreationForm):
                    orig = view_cls.form_valid
                    class DynamicRegisterForm(form_cls):
                        def __init__(self, *args, **kwargs):
                            super().__init__(*args, **kwargs)
                            self.request = request
                        def clean_username(self):
                            uname = self.cleaned_data.get('username')
                            from django.contrib.auth.models import User as AuthUser
                            if AuthUser._default_manager.db_manager(alias).filter(username=uname).exists():
                                raise forms.ValidationError(self.error_messages.get('duplicate_username', 'Username taken'), code='duplicate_username')
                            return uname
                        def save(self, commit=True):
                            u = super().save(commit=False)
                            u.save(using=alias)
                            return u
                        def validate_unique(self):
                            pass
                    view_cls.form_class = DynamicRegisterForm
                    def form_valid(self, form):
                        resp = orig(self, form)
                        from django.contrib.auth.models import User as AuthUser
                        u = AuthUser._default_manager.db_manager(alias).get(pk=self.request.user.pk)
                        u.backend = 'django.contrib.auth.backends.ModelBackend'
                        login(self.request, u)
                        if alias != 'default':
                            request.session['project_db_alias'] = alias
                        return resp
                    view_cls.form_valid = form_valid
                    view_cls._project_patched = True
                    return None

            # Patch LoginView
            if issubclass(view_cls, LoginView):
                # Custom auth form to restrict default-DB users
                class ProjectAuthForm(AuthenticationForm):
                    def confirm_login_allowed(self, user):
                        current = getattr(self.request, 'project_db_alias', 'default')
                        user_db = getattr(user._state, 'db', 'default')
                        if current != 'default' and user_db == 'default':
                            raise forms.ValidationError('Invalid username or password', code='invalid_login')
                        super().confirm_login_allowed(user)
                view_cls.authentication_form = ProjectAuthForm

                # Patch form_valid to record alias
                orig_val = view_cls.form_valid
                def form_valid(self, form):
                    # before Django logs in, force the right backend
                    user = form.get_user()
                    backend = (
                        'core.backends.ProjectDBBackend'
                        if alias != 'default'
                        else 'django.contrib.auth.backends.ModelBackend'
                    )
                    user.backend = backend
                    # let Django do its normal login() now
                    resp = orig_val(self, form)
                    # now stash project alias
                    if alias != 'default':
                        self.request.session['project_db_alias'] = alias
                    return resp
                view_cls.form_valid = form_valid

                # Patch redirect under project path
                orig_url = view_cls.get_success_url
                def get_success_url(self):
                    nxt = self.request.POST.get('next') or self.request.GET.get('next')
                    if nxt:
                        return nxt
                    m = re.match(r'^/projects/(\d+)', self.request.path_info)
                    if m:
                        return f"/projects/{m.group(1)}/"
                    return orig_url(self)
                view_cls.get_success_url = get_success_url

                view_cls._project_patched = True
                return None

        return None
class ProjectSessionAuthMiddleware:
    """
    Ensures project pages only accept project-DB logins;
    supports both session-based and JWT authentication with user syncing.
    """
    def __init__(self, get_response):
        self.get_response = get_response
        self.User = get_user_model()
        self.jwt_auth = JWTAuthentication()

    def __call__(self, request):
        alias = getattr(request, 'project_db_alias', 'default')
        user = request.user

        # If we’re under /projects/<id>/…, try to authenticate
        if alias.startswith('project_'):
            # First, try session-based authentication
            uid = request.session.get(SESSION_KEY)
            if uid:
                try:
                    u = self.User._default_manager.db_manager(alias).get(pk=uid)
                    u._state.db = alias
                    request.user = u
                    u.backend = 'core.backends.ProjectDBBackend'
                    login(request, u)
                except self.User.DoesNotExist:
                    logout(request)
                    user = AnonymousUser()

            # If no session user, try JWT authentication
            if not user.is_authenticated:
                auth_header = request.headers.get('Authorization', '')
                if auth_header.startswith('Bearer '):
                    token = auth_header.split(' ')[1]
                    try:
                        validated_token = self.jwt_auth.get_validated_token(token)
                        jwt_user = self.jwt_auth.get_user(validated_token)
                        # Check if user exists in project-specific database
                        try:
                            project_user = self.User._default_manager.db_manager(alias).get(pk=jwt_user.pk)
                            project_user._state.db = alias
                            request.user = project_user
                            project_user.backend = 'core.backends.ProjectDBBackend'
                            login(request, project_user)
                        except self.User.DoesNotExist:
                            # Sync user from default database to project database
                            default_user = self.User._default_manager.db_manager('default').get(pk=jwt_user.pk)
                            project_user = self.User(
                                id=default_user.id,
                                username=default_user.username,
                                email=default_user.email,
                                # Add other necessary fields
                            )
                            project_user.save(using=alias)
                            project_user._state.db = alias
                            request.user = project_user
                            project_user.backend = 'core.backends.ProjectDBBackend'
                            login(request, project_user)
                    except (InvalidToken, TokenError) as e:
                        request.user = AnonymousUser()

        return self.get_response(request)
    


from channels.middleware import BaseMiddleware

from asgiref.sync import sync_to_async

@sync_to_async
def get_user_from_token(token):
    try:
        validated = JWTAuthentication().get_validated_token(token)
        return JWTAuthentication().get_user(validated)
    except (InvalidToken, TokenError):
        return AnonymousUser()

class QueryAuthMiddleware(BaseMiddleware):
    async def __call__(self, scope, receive, send):
        qs = parse_qs(scope.get("query_string", b"").decode())
        token_list = qs.get("token")

        if token_list:
            scope["user"] = await get_user_from_token(token_list[0])
        else:
            scope["user"] = AnonymousUser()

        return await super().__call__(scope, receive, send)

class QueryAuthMiddlewareInstance:
    def __init__(self, scope, inner):
        self.scope = dict(scope)
        self.inner = inner

    async def __call__(self, receive, send):
        # parse token
        qs = parse_qs(self.scope.get("query_string", b"").decode())
        token_list = qs.get("token", None)
        user = AnonymousUser()

        if token_list:
            token = token_list[0]
            try:
                validated = JWTAuthentication().get_validated_token(token)
                user = JWTAuthentication().get_user(validated)
            except (InvalidToken, TokenError):
                pass

        self.scope["user"] = user
        inner = self.inner(self.scope)
        return await inner(receive, send)

def QueryAuthMiddlewareStack(inner):
    return QueryAuthMiddleware(inner)

# core/middleware.py

class ThemeInjectorMiddleware:
    """
    For any HTML page under /projects/<id>/ we inject the Topic Listing
    theme's CSS/JS into the <head> and just before </body>, without touching
    the DB-stored templates.
    """
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)

        # Only target HTML project pages
        if (
            request.path.startswith('/projects/')
            and response.get('Content-Type', '').startswith('text/html')
        ):
            content = response.content.decode(response.charset)

            # 1) CSS links to inject in <head>
            head_inject = """
    <link rel="stylesheet" href="/static/tm-590-topic-listing/assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="/static/tm-590-topic-listing/assets/css/fontawesome.min.css">
    <link rel="stylesheet" href="/static/tm-590-topic-listing/assets/css/templatemo-topic-listing.css">
            """

            # 2) JS scripts to inject just before </body>
            body_inject = """
    <script src="/static/tm-590-topic-listing/assets/js/jquery.min.js"></script>
    <script src="/static/tm-590-topic-listing/assets/js/bootstrap.bundle.min.js"></script>
    <script src="/static/tm-590-topic-listing/assets/js/templatemo-script.js"></script>
            """

            # Insert CSS before </head>
            content = content.replace('</head>', head_inject + '\n</head>')

            # Insert JS before </body>
            content = content.replace('</body>', body_inject + '\n</body>')

            response.content = content.encode(response.charset)
            response['Content-Length'] = len(response.content)

        return response

class PreviewDiffMiddleware(MiddlewareMixin):
    """
    If the request bears preview_change_id & preview_mode,
    load the diff JSON into request.preview_diff.
    """
    def process_request(self, request):
        change_id = request.GET.get('preview_change_id')
        mode      = request.GET.get('preview_mode')  # 'before' or 'after'
        if change_id and mode in ('before', 'after'):
            try:
                cr = AIChangeRequest.objects.get(id=change_id,
                                                 project_id=request.resolver_match.kwargs.get('project_pk'))
                request.preview_diff = json.loads(cr.diff or "{}")
                request.preview_mode = mode
                request.preview_change_id = change_id
            except AIChangeRequest.DoesNotExist:
                request.preview_diff = {}
                request.preview_mode = None

import ast
import types
import builtins
import importlib
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from rest_framework.routers import DefaultRouter
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework import status
from create_api.models import URLFile
from create_api.views import (
    CurrentUserAPIView,
    GenerateAPIView,
    AvailableModelsAPIView,
    upload_files,
    GenerateModelCodeAPIView,
    UserModelViewSet,
    PreviewRunAPIView
)
from django.urls import re_path  # or path with converters
from core.views import serve_db_static, serve_db_media,serve_drf_static
def sanitize_content(content):
    return content.replace('\xa0', ' ')  # Replace non-breaking spaces

urlpatterns = []

# 1) base on-disk urlpatterns
if settings.ROOT_URLCONF and settings.ROOT_URLCONF != __name__:
    try:
        disk = importlib.import_module(settings.ROOT_URLCONF)
        urlpatterns = list(getattr(disk, "urlpatterns", []))
    except ImportError:
        pass

# 2) admin & fixed API endpoints
urlpatterns += [
    path("admin/", admin.site.urls),
    path("api/", include("create_api.urls")),
    path("generate-api/", GenerateAPIView.as_view(), name="generate-api"),
    path("available-models/", AvailableModelsAPIView.as_view(), name="available-models"),
    path("upload-files/", upload_files, name="upload_files"),
     # 1) DB‐backed static first
    re_path(r'^static/(?P<path>.*)$', serve_db_static, name='db_static'),
       # 1) DRF browsable‐API assets from disk
    re_path(r'^static/rest_framework/(?P<path>.*)$', serve_drf_static),

    # 2) DB‐backed static after that
    re_path(r'^static/(?P<path>.*)$', serve_db_static, name='db_static'),
    # 2) DB‐backed media next
    re_path(r'^media/(?P<path>.*)$', serve_db_media, name='db_media'),
]

# 3) project-level URLFiles (with AST)
for urlfile in URLFile.objects.filter(app__isnull=True):
    pid = urlfile.project.id
    module_tag = f"project_{pid}"
    namespace = module_tag
    raw_code = sanitize_content(urlfile.content)

    app_names = [app.name for app in urlfile.project.apps.all()]
    module_prefix = f"projects.{module_tag}.apps"

    try:
        tree = ast.parse(raw_code)

        class URLTransformer(ast.NodeTransformer):
            def visit_ImportFrom(self, node):
                if node.module:
                    root = node.module.split(".", 1)[0]
                    if root in app_names:
                        node.module = f"{module_prefix}.{node.module}"
                return node

            def visit_Call(self, node):
                if isinstance(node.func, ast.Name) and node.func.id == "include":
                    if node.args and isinstance(node.args[0], ast.Constant) and isinstance(node.args[0].value, str):
                        modstr = node.args[0].value
                        root = modstr.split(".", 1)[0]
                        if root in app_names:
                            node.args[0].value = f"{module_prefix}.{modstr}"
                return self.generic_visit(node)

        tree = URLTransformer().visit(tree)
        ast.fix_missing_locations(tree)
        compiled = compile(tree, filename=f"<project_{pid}_urls>", mode="exec")

        # Custom import to redirect local app modules
        real_import = builtins.__import__
        def db_import(name, globals=None, locals=None, fromlist=(), level=0):
            root = name.split(".", 1)[0]
            if root in app_names:
                name = f"{module_prefix}.{name}"
            return real_import(name, globals, locals, fromlist, level)

        exec_globals = {
            "__name__": f"projects.{module_tag}",
            "__builtins__": {**builtins.__dict__, "__import__": db_import},
        }

        exec(compiled, exec_globals)

        if "urlpatterns" in exec_globals:
            urlpatterns.append(
                path(f"projects/{pid}/", include(exec_globals["urlpatterns"]))
            )
    except Exception as e:
            print(f"❌ Failed loading project {pid}: {e}")


# 4) app-level URLFiles
for urlfile in URLFile.objects.exclude(app__isnull=True):
    pid = urlfile.project.id
    module_tag = f"project_{pid}"
    appname = urlfile.app.name
    modstr = f"projects.{module_tag}.apps.{appname}.urls"
    try:
        importlib.import_module(modstr)
        urlpatterns.append(
               path(
        f"projects/{pid}/{appname}/",
        include(modstr),
    )
        )
        # print(f"✅ Added app-level URL patterns for project {pid}, app {appname}")
    except ImportError:
        print(f"❌ Failed to import app-level module: {modstr}")
        continue

# 5) DRF router
router = DefaultRouter()
router.register(r"usermodels", UserModelViewSet)
urlpatterns.append(path("", include(router.urls)))

# 6) Dynamic run-project route
class RunProjectAPIView(APIView):
    def post(self, request, project_pk):
        full_url = request.build_absolute_uri(f"/projects/{project_pk}/")
        return Response({'url': full_url}, status=status.HTTP_200_OK)

urlpatterns.append(
    path('projects/<int:project_pk>/run/', RunProjectAPIView.as_view(), name='run-project'),

)
urlpatterns.append(
           path('projects/<int:project_pk>/preview/run/',
         PreviewRunAPIView.as_view(), name='preview-run'),
)
urlpatterns.append(
    path(
        f"projects/{pid}/",
        include((exec_globals["urlpatterns"], namespace)),
    )
)

# Debug output
# print("✅ Final URL patterns:")
# for pattern in urlpatterns:
#     print(pattern)

# Optional: show key URLFile objects
users_urlfile = URLFile.objects.filter(project_id=1, app__name='users', path='users/urls.py')
posts_urlfile = URLFile.objects.filter(project_id=1, app__name='posts', path='posts/urls.py')
# print(users_urlfile, posts_urlfile)
